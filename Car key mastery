-- 基本服務與玩家
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- GUI 主體
local ScreenGui = Instance.new("ScreenGui", game.CoreGui)
ScreenGui.Name = "MaolingHub"

-- 修正：主框架樣式
local Frame = Instance.new("Frame", ScreenGui)
Frame.Size = UDim2.new(0, 450, 0, 350)
Frame.Position = UDim2.new(0.5, -225, 0.5, -175)
Frame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Draggable = true

-- 添加漸層效果
local gradient = Instance.new("UIGradient", Frame)
gradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(25, 25, 35)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(35, 35, 50))
}
gradient.Rotation = 45

-- 添加外發光效果
local stroke = Instance.new("UIStroke", Frame)
stroke.Color = Color3.fromRGB(100, 150, 255)
stroke.Thickness = 2
stroke.Transparency = 0.5

Instance.new("UICorner", Frame).CornerRadius = UDim.new(0, 15)

-- 修正：標題樣式
local Title = Instance.new("TextLabel", Frame)
Title.Size = UDim2.new(1, -80, 0, 50)
Title.Position = UDim2.new(0, 15, 0, 0)
Title.BackgroundTransparency = 1
Title.Text = "✨ 貓玲的腳本區 ✨車鑰匙精通v0.18"
Title.Font = Enum.Font.GothamBold
Title.TextSize = 22
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextXAlignment = Enum.TextXAlignment.Left

-- 添加標題發光效果
local titleStroke = Instance.new("UIStroke", Title)
titleStroke.Color = Color3.fromRGB(100, 150, 255)
titleStroke.Thickness = 1
titleStroke.Transparency = 0.3

-- 修正：關閉按鈕樣式和功能
local Close = Instance.new("TextButton", Frame)
Close.Size = UDim2.new(0, 35, 0, 35)
Close.Position = UDim2.new(1, -40, 0, 8)
Close.Text = "x"
Close.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
Close.TextColor3 = Color3.fromRGB(255, 255, 255)
Close.Font = Enum.Font.GothamBold
Close.TextSize = 18
Close.BorderSizePixel = 0

-- 添加關閉按鈕效果
local closeGradient = Instance.new("UIGradient", Close)
closeGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(220, 60, 60)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 40, 40))
}

Instance.new("UICorner", Close).CornerRadius = UDim.new(0, 8)

-- 修正：關閉按鈕功能
Close.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
    _G.maolingHubLoaded = false -- 重置載入狀態
end)

-- 修正：最小化按鈕樣式
local Minimize = Instance.new("TextButton", Frame)
Minimize.Size = UDim2.new(0, 35, 0, 35)
Minimize.Position = UDim2.new(1, -80, 0, 8)
Minimize.Text = "─"
Minimize.BackgroundColor3 = Color3.fromRGB(100, 100, 120)
Minimize.TextColor3 = Color3.fromRGB(255, 255, 255)
Minimize.Font = Enum.Font.GothamBold
Minimize.TextSize = 16
Minimize.BorderSizePixel = 0

local minimizeGradient = Instance.new("UIGradient", Minimize)
minimizeGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 100, 120)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 80, 100))
}

Instance.new("UICorner", Minimize).CornerRadius = UDim.new(0, 8)

-- 修正：側邊欄為可滾動
local SideBar = Instance.new("ScrollingFrame", Frame)
SideBar.Size = UDim2.new(0, 130, 1, -55)
SideBar.Position = UDim2.new(0, 5, 0, 50)
SideBar.BackgroundColor3 = Color3.fromRGB(35, 35, 50)
SideBar.BorderSizePixel = 0
SideBar.ScrollBarThickness = 6
SideBar.CanvasSize = UDim2.new(0, 0, 0, 200)
SideBar.AutomaticCanvasSize = Enum.AutomaticSize.Y
SideBar.ScrollingDirection = Enum.ScrollingDirection.Y

-- 添加側邊欄樣式
local sidebarGradient = Instance.new("UIGradient", SideBar)
sidebarGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(35, 35, 50)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(45, 45, 65))
}

Instance.new("UICorner", SideBar).CornerRadius = UDim.new(0, 10)

-- 添加UIListLayout到側邊欄
local sidebarLayout = Instance.new("UIListLayout", SideBar)
sidebarLayout.Padding = UDim.new(0, 8)
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center

-- 修正：內容區域
local Content = Instance.new("Frame", Frame)
Content.Size = UDim2.new(1, -145, 1, -55)
Content.Position = UDim2.new(0, 140, 0, 50)
Content.BackgroundColor3 = Color3.fromRGB(40, 40, 60)
Content.BorderSizePixel = 0

local contentGradient = Instance.new("UIGradient", Content)
contentGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(40, 40, 60)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(50, 50, 75))
}

Instance.new("UICorner", Content).CornerRadius = UDim.new(0, 10)

-- 修正：縮小功能的尺寸
local isMinimized = false
local fullSize = UDim2.new(0, 450, 0, 350)
local miniSize = UDim2.new(0, 450, 0, 50)

Minimize.MouseButton1Click:Connect(function()
    isMinimized = not isMinimized
    SideBar.Visible = not isMinimized
    Content.Visible = not isMinimized
    Frame.Size = isMinimized and miniSize or fullSize
end)

-- 修正：簡單高亮文字的分區按鈕樣式
local function createSectionButton(text, order, parent)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0, 120, 0, 45)
    btn.Text = text
    btn.BackgroundColor3 = Color3.fromRGB(85, 85, 105)
    
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.TextTransparency = 0
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.BorderSizePixel = 0
    
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 10)
    
    local btnStroke = Instance.new("UIStroke", btn)
    btnStroke.Color = Color3.fromRGB(150, 180, 255)
    btnStroke.Thickness = 1
    btnStroke.Transparency = 0.6
    
    btn.MouseEnter:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(105, 105, 125)
        btnStroke.Transparency = 0.3
    end)
    
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(85, 85, 105)
        btnStroke.Transparency = 0.6
    end)
    
    return btn
end

-- 添加滾動框樣式改善
local function styleScrollFrame(scrollFrame)
    scrollFrame.BackgroundColor3 = Color3.fromRGB(45, 45, 65)
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 150, 255)
    
    local scrollGradient = Instance.new("UIGradient", scrollFrame)
    scrollGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 45, 65)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(55, 55, 80))
    }
    
    Instance.new("UICorner", scrollFrame).CornerRadius = UDim.new(0, 8)
end

-- 創建滾動按鈕的函數
local function createScrollButton(text, order, parent, height)
    local btn = Instance.new("TextButton", parent)
    btn.Size = UDim2.new(0, 180, 0, height or 40)
    btn.Position = UDim2.new(0.5, -90, 0, (order - 1) * (height + 10 or 50))
    btn.Text = text
    btn.BackgroundColor3 = Color3.fromRGB(80, 140, 220)
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = Enum.Font.GothamBold
    btn.TextSize = 16
    btn.BorderSizePixel = 0
    
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)
    
    local btnStroke = Instance.new("UIStroke", btn)
    btnStroke.Color = Color3.fromRGB(100, 180, 255)
    btnStroke.Thickness = 1
    btnStroke.Transparency = 0.5
    
    btn.MouseEnter:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(100, 160, 240)
        btnStroke.Transparency = 0.2
    end)
    
    btn.MouseLeave:Connect(function()
        btn.BackgroundColor3 = Color3.fromRGB(80, 140, 220)
        btnStroke.Transparency = 0.5
    end)
    
    return btn
end

-- 創建文字輸入框的函數
local function createTextBox(placeholder, order, parent, height)
    local textBox = Instance.new("TextBox", parent)
    textBox.Size = UDim2.new(0, 180, 0, height or 40)
    textBox.Position = UDim2.new(0.5, -90, 0, (order - 1) * (height + 10 or 50))
    textBox.PlaceholderText = placeholder
    textBox.Text = ""
    textBox.BackgroundColor3 = Color3.fromRGB(60, 60, 80)
    textBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    textBox.PlaceholderColor3 = Color3.fromRGB(150, 150, 150)
    textBox.Font = Enum.Font.Gotham
    textBox.TextSize = 14
    textBox.BorderSizePixel = 0
    textBox.ClearTextOnFocus = false
    
    Instance.new("UICorner", textBox).CornerRadius = UDim.new(0, 8)
    
    local textBoxStroke = Instance.new("UIStroke", textBox)
    textBoxStroke.Color = Color3.fromRGB(100, 150, 255)
    textBoxStroke.Thickness = 1
    textBoxStroke.Transparency = 0.7
    
    textBox.Focused:Connect(function()
        textBoxStroke.Transparency = 0.3
    end)
    
    textBox.FocusLost:Connect(function()
        textBoxStroke.Transparency = 0.7
    end)
    
    return textBox
end

-- 創建下拉選單的函數
local function createDropdown(options, order, parent, height)
    local dropdown = Instance.new("TextButton", parent)
    dropdown.Size = UDim2.new(0, 180, 0, height or 40)
    dropdown.Position = UDim2.new(0.5, -90, 0, (order - 1) * (height + 10 or 50))
    dropdown.Text = options[1] or "選擇選項"
    dropdown.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
    dropdown.TextColor3 = Color3.fromRGB(255, 255, 255)
    dropdown.Font = Enum.Font.Gotham
    dropdown.TextSize = 14
    dropdown.BorderSizePixel = 0
    
    Instance.new("UICorner", dropdown).CornerRadius = UDim.new(0, 8)
    
    local dropdownStroke = Instance.new("UIStroke", dropdown)
    dropdownStroke.Color = Color3.fromRGB(100, 150, 255)
    dropdownStroke.Thickness = 1
    dropdownStroke.Transparency = 0.7
    
    local selectedIndex = 1
    local isOpen = false
    
    -- 創建下拉箭頭
    local arrow = Instance.new("TextLabel", dropdown)
    arrow.Size = UDim2.new(0, 20, 1, 0)
    arrow.Position = UDim2.new(1, -25, 0, 0)
    arrow.BackgroundTransparency = 1
    arrow.Text = "▼"
    arrow.TextColor3 = Color3.fromRGB(255, 255, 255)
    arrow.Font = Enum.Font.Gotham
    arrow.TextSize = 12
    arrow.TextXAlignment = Enum.TextXAlignment.Center
    arrow.TextYAlignment = Enum.TextYAlignment.Center
    
    -- 創建選項列表容器
    local optionsList = Instance.new("Frame", dropdown)
    optionsList.Size = UDim2.new(1, 0, 0, #options * 35)
    optionsList.Position = UDim2.new(0, 0, 1, 5)
    optionsList.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
    optionsList.BorderSizePixel = 0
    optionsList.Visible = false
    optionsList.ZIndex = 100
    dropdown.ZIndex = 99
    
    Instance.new("UICorner", optionsList).CornerRadius = UDim.new(0, 8)
    
    local optionsStroke = Instance.new("UIStroke", optionsList)
    optionsStroke.Color = Color3.fromRGB(100, 150, 255)
    optionsStroke.Thickness = 1
    optionsStroke.Transparency = 0.5
    
    -- 創建選項按鈕
    for i, option in ipairs(options) do
        local optionBtn = Instance.new("TextButton", optionsList)
        optionBtn.Size = UDim2.new(1, -4, 0, 30)
        optionBtn.Position = UDim2.new(0, 2, 0, (i - 1) * 35 + 2)
        optionBtn.Text = option
        optionBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
        optionBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
        optionBtn.Font = Enum.Font.Gotham
        optionBtn.TextSize = 13
        optionBtn.BorderSizePixel = 0
        optionBtn.ZIndex = 101
        
        Instance.new("UICorner", optionBtn).CornerRadius = UDim.new(0, 6)
        
        optionBtn.MouseEnter:Connect(function()
            optionBtn.BackgroundColor3 = Color3.fromRGB(90, 90, 110)
        end)
        
        optionBtn.MouseLeave:Connect(function()
            optionBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 90)
        end)
        
        optionBtn.MouseButton1Click:Connect(function()
            selectedIndex = i
            dropdown.Text = option
            optionsList.Visible = false
            isOpen = false
            arrow.Text = "▼"
        end)
    end
    
    -- 主按鈕點擊事件
    dropdown.MouseButton1Click:Connect(function()
        isOpen = not isOpen
        optionsList.Visible = isOpen
        arrow.Text = isOpen and "▲" or "▼"
    end)
    
    -- 返回下拉選單和獲取選擇的函數
    local function getSelection()
        return selectedIndex, options[selectedIndex]
    end
    
    return dropdown, getSelection
end

-- =================================
-- 修复版：车钥匙精通分区（触控版）
-- =================================

-- 创建车钥匙精通分区按钮
local CarMasterySection = createSectionButton("车钥匙精通", 1, SideBar)

-- 创建车钥匙精通内容区域
local CarMasteryContent = Instance.new("ScrollingFrame", Content)
CarMasteryContent.Size = UDim2.new(1, -10, 1, -10)
CarMasteryContent.Position = UDim2.new(0, 5, 0, 5)
CarMasteryContent.BackgroundTransparency = 1
CarMasteryContent.BorderSizePixel = 0
CarMasteryContent.ScrollBarThickness = 6
CarMasteryContent.CanvasSize = UDim2.new(0, 0, 0, 500)
CarMasteryContent.AutomaticCanvasSize = Enum.AutomaticSize.Y
CarMasteryContent.ScrollingDirection = Enum.ScrollingDirection.Y
CarMasteryContent.Visible = true

styleScrollFrame(CarMasteryContent)

-- 分区按钮点击事件
CarMasterySection.MouseButton1Click:Connect(function()
    for _, child in pairs(Content:GetChildren()) do
        if child:IsA("ScrollingFrame") then
            child.Visible = false
        end
    end
    CarMasteryContent.Visible = true
end)

-- 虚拟按键移动功能变量
local isAutoMoving = false
local autoMoveConnection = nil
local moveStartTime = 0
local currentDirection = "W" -- "W"(前进), "S"(后退), "STOP"(停止)
local movePhase = "moving" -- "moving"(移动中), "stopping"(停止中)
local phaseStartTime = 0

-- 帮助模式功能变量 (修复版)
local isHelperMode = false
local helperConnection = nil
local ragdollConnection = nil
local lastHelperMoveTime = 0
local lastPositionUpdateTime = 0 -- 新增：位置更新计时器
local HELPER_HEIGHT_INTERVAL = 0.1 -- 高度同步间隔：0.1秒
local HELPER_POSITION_INTERVAL = 3 -- 位置移动间隔：3秒
local targetPlayerName = ""
local helperMode = "normal" -- "normal" 或 "reset"
local targetXZ = nil -- 存储目标的X、Z坐标

-- 新增：防止重复重置的变量
local isResetting = false
local lastRagdollTime = 0
local RAGDOLL_COOLDOWN = 5 -- 重置冷却时间5秒

-- 创建玩家名称输入框
local PlayerNameInput = createTextBox("输入玩家名称", 1, CarMasteryContent, 45)

-- 创建模式选择下拉选单
local ModeDropdown, getModeSelection = createDropdown({"被撞后不重置", "被撞后重置"}, 2, CarMasteryContent, 45)

-- 创建帮助模式按钮
local HelperModeButton = createScrollButton("开始帮助模式", 3, CarMasteryContent, 45)

-- 创建虚拟按键移动按钮
local VirtualMoveButton = createScrollButton("虚拟按键移动", 4, CarMasteryContent, 45)

-- 创建状态显示标签
local StatusLabel = Instance.new("TextLabel", CarMasteryContent)
StatusLabel.Size = UDim2.new(0, 180, 0, 25)
StatusLabel.Position = UDim2.new(0.5, -90, 0, 230)
StatusLabel.BackgroundTransparency = 1
StatusLabel.Text = "状态：停止"
StatusLabel.Font = Enum.Font.Gotham
StatusLabel.TextSize = 14
StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusLabel.TextXAlignment = Enum.TextXAlignment.Center

-- 修复版：寻找指定名称玩家的函数
local function findPlayerByName(playerName)
    if not playerName or playerName == "" then
        return nil
    end
    
    -- 完全匹配
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name == playerName then
            return player
        end
    end
    
    -- 部分匹配（不区分大小写）
    local lowerName = playerName:lower()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Name:lower():find(lowerName) then
            return player
        end
    end
    
    return nil
end

-- 新版：计算目标位置的函数（分离高度和XZ坐标）
local function calculateTargetPosition(targetPlayer)
    if not targetPlayer or not targetPlayer.Character or not targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return nil, nil
    end
    
    local targetRootPart = targetPlayer.Character.HumanoidRootPart
    local targetPosition = targetRootPart.Position
    local targetLookDirection = targetRootPart.CFrame.LookVector
    
    -- 计算目标玩家面向方向前50单位的X、Z坐标
    local targetXZPosition = Vector3.new(
        targetPosition.X + (targetLookDirection.X * 50),
        0, -- Y坐标暂时设为0，后面会单独处理
        targetPosition.Z + (targetLookDirection.Z * 50)
    )
    
    -- 返回目标的Y坐标和XZ位置
    return targetPosition.Y, targetXZPosition
end

-- 新版：移动到指定位置的函数（支持只更新高度或完整移动）
local function moveToPosition(targetY, targetXZ, onlyHeight)
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    
    local humanoidRootPart = LocalPlayer.Character.HumanoidRootPart
    local currentPosition = humanoidRootPart.Position
    
    local newPosition
    if onlyHeight then
        -- 只更新Y坐标（高度），保持当前的X、Z坐标
        newPosition = Vector3.new(currentPosition.X, targetY, currentPosition.Z)
    else
        -- 完整移动：使用目标的XZ坐标和Y坐标
        newPosition = Vector3.new(targetXZ.X, targetY, targetXZ.Z)
    end
    
    local newCFrame = CFrame.new(newPosition, newPosition + humanoidRootPart.CFrame.LookVector)
    
    -- 使用 pcall 来安全设置属性
    pcall(function()
        humanoidRootPart.CFrame = newCFrame
        humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
        
        -- 尝试设置 AngularVelocity，如果不存在就跳过
        if humanoidRootPart:FindFirstChild("AngularVelocity") then
            humanoidRootPart.AngularVelocity = Vector3.new(0, 0, 0)
        elseif humanoidRootPart:FindFirstChild("BodyAngularVelocity") then
            humanoidRootPart.BodyAngularVelocity.AngularVelocity = Vector3.new(0, 0, 0)
        end
    end)
    
    return true
end

-- 修复版：重置角色的函数
local function resetCharacter()
    print("执行重置...")
    if LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            -- 使用 pcall 来安全重置
            pcall(function()
                humanoid.Health = 0
            end)
        else
            -- 如果找不到 Humanoid，尝试其他方法
            pcall(function()
                LocalPlayer.Character:Destroy()
            end)
        end
    end
end

-- 修复版：传送到 Lobby 的函数
local function teleportToLobby()
    local maxAttempts = 3 -- 最大尝试次数
    local attempt = 0
    
    while attempt < maxAttempts do
        attempt = attempt + 1
        
        -- 等待角色完全载入
        local waitTime = 0
        repeat 
            wait(0.1)
            waitTime = waitTime + 0.1
        until (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) or waitTime >= 5
        
        if waitTime >= 5 then
            print("等待角色载入超时，尝试 " .. attempt)
            if attempt < maxAttempts then
                continue
            else
                return false
            end
        end
        
        local lobbyTeleport = Workspace:FindFirstChild("Lobby")
        if lobbyTeleport then
            lobbyTeleport = lobbyTeleport:FindFirstChild("Teleport1")
        end
        
        if lobbyTeleport and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
            print("传送到 Lobby... (尝试 " .. attempt .. ")")
            
            -- 使用 pcall 来安全传送
            local success = pcall(function()
                LocalPlayer.Character.HumanoidRootPart.CFrame = lobbyTeleport.CFrame
                LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
            end)
            
            if success then
                wait(0.5) -- 等待传送稳定
                return true
            else
                print("传送失败，尝试 " .. attempt)
            end
        else
            print("找不到 Workspace.Lobby.Teleport1，尝试 " .. attempt)
        end
        
        if attempt < maxAttempts then
            wait(1) -- 等待1秒后重试
        end
    end
    
    return false
end

-- 检查玩家是否在 regulararena 的函数
local function checkPlayerInRegularArena(playerName)
    if not playerName or playerName == "" then
        return false
    end
    
    -- 检查 workspace.玩家名.regulararena 是否存在
    local playerPath = Workspace:FindFirstChild(playerName)
    if playerPath then
        local regularArena = playerPath:FindFirstChild("regulararena")
        if regularArena then
            print("检测到 " .. playerName .. " 在 regulararena")
            return true
        end
    end
    
    print(playerName .. " 不在 regulararena 或路径不存在")
    return false
end

-- 修复版：检查 Ragdoll 状态的函数
local function isInRagdoll()
    if not LocalPlayer.Character then return false end
    
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    -- 检查多种 ragdoll 状态
    local ragdollStates = {
        humanoid.PlatformStand,
        humanoid.Sit,
        humanoid:GetState() == Enum.HumanoidStateType.Physics,
        humanoid:GetState() == Enum.HumanoidStateType.Ragdoll
    }
    
    for _, state in pairs(ragdollStates) do
        if state then
            local currentTime = tick()
            -- 检查冷却时间，避免频繁重置
            if currentTime - lastRagdollTime >= RAGDOLL_COOLDOWN then
                lastRagdollTime = currentTime
                return true
            else
                return false -- 在冷却时间内，不触发重置
            end
        end
    end
    
    return false
end

-- 修复版：处理重置后的传送和检查逻辑
local function handleResetTeleport()
    if isResetting then
        print("已经在重置过程中，跳过")
        return
    end
    
    isResetting = true -- 设置重置标志
    StatusLabel.Text = "状态：重置中，请稍候..."
    
    spawn(function()
        -- 等待角色重新载入
        local waitTime = 0
        local maxWaitTime = 10 -- 最大等待时间10秒
        
        repeat 
            wait(0.1)
            waitTime = waitTime + 0.1
        until (LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")) or waitTime >= maxWaitTime
        
        if waitTime >= maxWaitTime then
            print("等待角色重新载入超时")
            StatusLabel.Text = "状态：重置失败，角色载入超时"
            isResetting = false
            return
        end
        
        print("角色重新载入完成")
        
        -- 先传送到 Lobby
        if teleportToLobby() then
            wait(1) -- 增加等待时间到1秒
            
            local maxRetries = 15 -- 增加最大重试次数
            local retryCount = 0
            
            while retryCount < maxRetries and isHelperMode and isResetting do
                retryCount = retryCount + 1
                print("第 " .. retryCount .. " 次检查目标玩家状态")
                
                -- 检查目标玩家是否在 regulararena
                if checkPlayerInRegularArena(targetPlayerName) then
                    print("目标玩家在 regulararena，准备传送")
                    StatusLabel.Text = "状态：目标在竞技场，传送中..."
                    
                    -- 等待一下确保稳定
                    wait(0.5)
                    
                    -- 重置相关变量
                    lastPositionUpdateTime = 0 -- 重置位置更新计时器，确保立即执行完整移动
                    targetXZ = nil
                    
                    -- 尝试传送到目标位置
                    local playerName, moveType = executeHelperMode()
                    if playerName then
                        StatusLabel.Text = "状态：重置完成，跟随 " .. playerName
                        lastHelperMoveTime = tick() -- 重置计时器
                        print("重置完成，成功传送到目标位置")
                        isResetting = false -- 重置完成，清除标志
                        return -- 成功后跳出
                    else
                        print("传送失败，继续重试...")
                        StatusLabel.Text = "状态：传送失败，重试中 (" .. retryCount .. "/" .. maxRetries .. ")"
                    end
                else
                    -- 目标玩家不在 regulararena，返回 Lobby 等待
                    print("目标玩家不在 regulararena，第 " .. retryCount .. " 次重试")
                    StatusLabel.Text = "状态：等待目标进入竞技场 (" .. retryCount .. "/" .. maxRetries .. ")"
                    
                    -- 确保在 Lobby
                    if not teleportToLobby() then
                        print("传送到 Lobby 失败")
                        StatusLabel.Text = "状态：传送失败"
                        break
                    end
                    
                    wait(1) -- 等待1秒后再检查
                end
            end
            
            -- 如果达到最大重试次数或其他原因退出循环
            if retryCount >= maxRetries and isHelperMode then
                print("达到最大重试次数，停止尝试")
                StatusLabel.Text = "状态：目标长时间不在竞技场，已停止"
            elseif not isHelperMode then
                print("帮助模式已停止")
                StatusLabel.Text = "状态：已停止"
            end
        else
            print("传送到 Lobby 失败")
            StatusLabel.Text = "状态：重置失败，无法传送到Lobby"
        end
        
        isResetting = false -- 清除重置标志
    end)
end

-- 新版：帮助模式主要执行函数
local function executeHelperMode()
    if not isHelperMode then return false end
    
    local currentTime = tick()
    local targetPlayer = findPlayerByName(targetPlayerName)
    
    if not targetPlayer then
        return nil
    end
    
    local targetY, targetXZPosition = calculateTargetPosition(targetPlayer)
    if not targetY or not targetXZPosition then
        return nil
    end
    
    -- 检查是否需要更新XZ位置（每3秒）
    local shouldUpdatePosition = (currentTime - lastPositionUpdateTime) >= HELPER_POSITION_INTERVAL
    
    if shouldUpdatePosition then
        -- 完整移动：更新XZ坐标和Y坐标
        if moveToPosition(targetY, targetXZPosition, false) then
            targetXZ = targetXZPosition -- 更新存储的目标XZ坐标
            lastPositionUpdateTime = currentTime
            return targetPlayer.Name, "完整移动"
        end
    else
        -- 只更新高度：保持当前XZ坐标，只同步Y坐标
        if moveToPosition(targetY, nil, true) then
            return targetPlayer.Name, "高度同步"
        end
    end
    
    return nil
end

-- 新版：帮助模式功能
HelperModeButton.MouseButton1Click:Connect(function()
    if not isHelperMode then
        -- 检查是否有输入玩家名称
        if PlayerNameInput.Text == "" then
            StatusLabel.Text = "状态：请输入玩家名称"
            return
        end
        
        -- 开始帮助模式
        print("启动帮助模式")
        isHelperMode = true
        isResetting = false -- 重置状态标志
        targetPlayerName = PlayerNameInput.Text
        local _, selectedMode = getModeSelection()
        helperMode = selectedMode == "被撞后重置" and "reset" or "normal"
        lastHelperMoveTime = tick()
        lastPositionUpdateTime = 0 -- 重置位置更新计时器，确保立即执行一次完整移动
        targetXZ = nil
        HelperModeButton.Text = "停止帮助模式"
        HelperModeButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
        
        -- 立即执行一次移动
        local playerName, moveType = executeHelperMode()
        if playerName then
            StatusLabel.Text = "状态：跟随 " .. playerName .. " (" .. (moveType or "开始") .. ")"
        else
            StatusLabel.Text = "状态：找不到玩家 " .. targetPlayerName
        end
        
        -- 创建帮助模式计时器（新版）
        helperConnection = RunService.Heartbeat:Connect(function()
            if not isHelperMode or isResetting then -- 如果正在重置则跳过
                return
            end
            
            local currentTime = tick()
            local timePassed = currentTime - lastHelperMoveTime
            
            -- 每0.1秒执行一次（用于高度同步和位置检查）
            if timePassed >= HELPER_HEIGHT_INTERVAL then
                lastHelperMoveTime = currentTime
                
                local playerName, moveType = executeHelperMode()
                if playerName then
                    if moveType == "完整移动" then
                        StatusLabel.Text = "状态：跟随 " .. playerName .. " (位置更新)"
                    else
                        StatusLabel.Text = "状态：跟随 " .. playerName .. " (高度同步)"
                    end
                else
                    StatusLabel.Text = "状态：找不到玩家 " .. targetPlayerName
                end
            end
        end)
        
        -- 如果选择了重置模式，监听 ragdoll 状态
        if helperMode == "reset" then
            ragdollConnection = RunService.Heartbeat:Connect(function()
                if not isHelperMode or isResetting then return end -- 如果正在重置则跳过
                
                if isInRagdoll() then
                    print("检测到 Ragdoll 状态，执行重置...")
                    StatusLabel.Text = "状态：检测到撞击，重置中..."
                    
                    -- 重置角色
                    resetCharacter()
                    
                    -- 执行重置后的传送和检查逻辑
                    handleResetTeleport()
                end
            end)
        end
    else
        -- 停止帮助模式
        print("停止帮助模式")
        isHelperMode = false
        isResetting = false -- 清除重置标志
        HelperModeButton.Text = "开始帮助模式"
        HelperModeButton.BackgroundColor3 = Color3.fromRGB(80, 140, 220)
        StatusLabel.Text = "状态：停止"
        targetXZ = nil
        
        -- 断开连接
        if helperConnection then
            helperConnection:Disconnect()
            helperConnection = nil
        end
        if ragdollConnection then
            ragdollConnection:Disconnect()
            ragdollConnection = nil
        end
    end
end)

-- 虚拟按键移动功能
local function simulateKeyPress(key)
    VirtualInputManager:SendKeyEvent(true, key, false, game)
end

local function simulateKeyRelease(key)
    VirtualInputManager:SendKeyEvent(false, key, false, game)
end

-- 自动虚拟按键移动功能
VirtualMoveButton.MouseButton1Click:Connect(function()
    if not isAutoMoving then
        -- 开始自动移动
        isAutoMoving = true
        moveStartTime = tick()
        phaseStartTime = tick()
        currentDirection = "W"
        movePhase = "moving"
        VirtualMoveButton.Text = "停止虚拟移动"
        VirtualMoveButton.BackgroundColor3 = Color3.fromRGB(220, 60, 60)
        StatusLabel.Text = "状态：前进中"
        
        -- 开始按下前进键
        simulateKeyPress(Enum.KeyCode.W)
        
        -- 自动移动循环
        autoMoveConnection = RunService.Heartbeat:Connect(function()
            local currentTime = tick()
            local phaseElapsedTime = currentTime - phaseStartTime
            
            if movePhase == "moving" then
                -- 移动阶段 - 持续3秒
                if phaseElapsedTime >= 3 then
                    -- 释放当前按键，进入停止阶段
                    simulateKeyRelease(Enum.KeyCode[currentDirection])
                    movePhase = "stopping"
                    phaseStartTime = currentTime
                    StatusLabel.Text = "状态：等速归零中..."
                end
            elseif movePhase == "stopping" then
                -- 停止阶段 - 持续1秒让速度归零
                if phaseElapsedTime >= 1 then
                    -- 切换方向并开始移动
                    if currentDirection == "W" then
                        currentDirection = "S"
                        StatusLabel.Text = "状态：后退中"
                    else
                        currentDirection = "W"
                        StatusLabel.Text = "状态：前进中"
                    end
                    
                    -- 按下新的按键
                    simulateKeyPress(Enum.KeyCode[currentDirection])
                    movePhase = "moving"
                    phaseStartTime = currentTime
                end
            end
        end)
    else
        -- 停止自动移动
        isAutoMoving = false
        VirtualMoveButton.Text = "虚拟按键移动"
        VirtualMoveButton.BackgroundColor3 = Color3.fromRGB(80, 140, 220)
        StatusLabel.Text = "状态：停止"
        
        if autoMoveConnection then
            autoMoveConnection:Disconnect()
            autoMoveConnection = nil
        end
        
        -- 释放当前按下的按键
        simulateKeyRelease(Enum.KeyCode[currentDirection])
    end
end)

-- 当GUI被销毁时清理所有连接
ScreenGui.AncestryChanged:Connect(function()
    if not ScreenGui.Parent then
        -- 清理帮助模式连接
        if helperConnection then
            helperConnection:Disconnect()
            helperConnection = nil
        end
        if ragdollConnection then
            ragdollConnection:Disconnect()
            ragdollConnection = nil
        end
        -- 清理虚拟移动连接
        if autoMoveConnection then
            autoMoveConnection:Disconnect()
            autoMoveConnection = nil
        end
        -- 确保释放所有按键
        for _, key in pairs({"W", "S"}) do
            pcall(function()
                simulateKeyRelease(Enum.KeyCode[key])
            end)
        end
        -- 重置所有状态
        isHelperMode = false
        isAutoMoving = false
        isResetting = false
        targetXZ = nil
    end
end)
